function [unitNormalVec] = IndicesMBToCartesianNormal(indices,a1,a2,a3)
	% INPUT:
	%		indices: four MB indices (hkil) describing the plane -- size (1,4)
	%                NOTE: Miller indices (hkl) with size (1,3) will also work
	%       a1,a2,a3: three linearly independent HCP lattice basis vectors -- each size (1,3)
    %       eps_VolLat: tolerance for linear independence of the three input HCP lattice vectors -- size (1)
	% OUTPUT:
	%		unitNormalVec: corresponding plane unit normal vector in cartesian coordinates -- size (1,3)
    
    % Tolerance for linear independence of three input HCP vectors:
    eps_VolLat = 1e-12;
    
	% HCP lattice basis vectors in a matrix form:
	basis = [a1;a2;a3]; % size (3,3)
	
	% Volume of cell generated by (a1,a2,a3):
	vol = det(basis); % size (1)
	
	% Checking linear independence of (a1,a2,a3):
	if abs(vol) < eps_VolLat
        warning('The volume generated by the three chosen HCP lattice vectors is %0.2s, which is less than the tolerance %0.2s.\n',abs(vol),eps_VolLat)
	end
	
	% Reciprocal lattice basis vectors:
	g1 = cross(a2,a3) ./ vol;
	g2 = cross(a3,a1) ./ vol;
	g3 = cross(a1,a2) ./ vol;
	
	if size(indices,2) == 4 % indices contains Miller-Bravais indices
		if indices(3) ~= -(indices(1) + indices(2))
            warning('i = %d != -(h + k) = %d for these Miller-Bravais indices.\n',indices(3),-(indices(1) + indices(2)))
		end
		indices(3) = []; % Removes linearly dependent index
	elseif size(indices,2) == 3 % indices contains Miller indices
		% Do nothing! Miller indices are apparently already given
    else
        error('The number of indices describing this plane is unexpectedly %d, and should be either 3 or 4.\n',size(indices,2))
	end
	
	% Miller indices in standard notation:
	h = indices(1);
	k = indices(2);
	l = indices(3);
	
	% Normal vector to (hkl) plane:
	normalVec = h*g1 + k*g2 + l*g3;
	
	% Unit normal vector:
	unitNormalVec = normalVec/norm(normalVec);
end